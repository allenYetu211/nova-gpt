{
    "sourceFile": "src/extensions/Record/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1681712555157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1681712555157,
            "name": "Commit-0",
            "content": "import { downloadPCM, downloadWAV, download } from './download/download';\r\nimport { compress, encodePCM, encodeWAV } from './transform/transform';\r\nimport Player from './player/player';\r\nimport Recorder from './recorder/recorder';\r\n\r\n\r\n// 构造函数参数格式\r\ninterface recorderConfig {\r\n  sampleBits?: number,        // 采样位数\r\n  sampleRate?: number,        // 采样率\r\n  numChannels?: number,       // 声道数\r\n  compiling?: boolean,        // 是否边录边播\r\n}\r\n\r\nclass Index extends Recorder {\r\n  private isrecording: boolean = false;       // 是否正在录音\r\n  private ispause: boolean = false;           // 是否是暂停\r\n  private isplaying: boolean = false;         // 是否正在播放\r\n\r\n  // @ts-ignore\r\n  public onplay: () => void;                  // 音频播放回调\r\n  // @ts-ignore\r\n  public onpauseplay: () => void;             // 音频暂停回调\r\n  // @ts-ignore\r\n  public onresumeplay: () => void;            // 音频恢复播放回调\r\n  // @ts-ignore\r\n  public onstopplay: () => void;              // 音频停止播放回调\r\n  // @ts-ignore\r\n  public onplayend: () => void;               // 音频正常播放结束\r\n  /**\r\n   * @param {Object} options 包含以下三个参数：\r\n   * sampleBits，采样位数，一般8,16，默认16\r\n   * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n   * numChannels，声道，1或2\r\n   */\r\n  constructor (options: recorderConfig = {}) {\r\n    super(options);\r\n  }\r\n\r\n  /**\r\n   * 重新修改配置\r\n   *\r\n   * @param {recorderConfig} [options={}]\r\n   * @memberof Recorder\r\n   */\r\n  public setOption(options: recorderConfig = {}) {\r\n    this.setNewOption(options);\r\n  }\r\n\r\n  /**\r\n   * Start the recording\r\n   */\r\n  start(): Promise<{}> {\r\n    if (this.isrecording) {\r\n      // 正在录音，则不允许\r\n      return Promise.reject();\r\n    }\r\n\r\n    this.isrecording = true;\r\n\r\n    return this.startRecord();\r\n  }\r\n\r\n  /**\r\n   * Pause the recording\r\n   */\r\n  pause(): void {\r\n    if (this.isrecording && !this.ispause) {\r\n      this.ispause = true;\r\n      // 当前不暂停的时候才可以暂停\r\n      this.pauseRecord();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 继续录音\r\n   */\r\n  resume(): void {\r\n    if (this.isrecording && this.ispause) {\r\n      this.ispause = false;\r\n      this.resumeRecord();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 停止录音\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  stop(): void {\r\n    if (this.isrecording) {\r\n      this.isrecording = false;\r\n      this.ispause = false;\r\n      this.stopRecord();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 播放录音\r\n   */\r\n  play(): void {\r\n    this.stop();\r\n    // 关闭前一次音频播放\r\n    this.isplaying = true;\r\n    this.onplay && this.onplay();\r\n    Player.addPlayEnd(this.onplayend);  // 注册播放完成后的回调事件\r\n\r\n    const dataV = this.getWAV();\r\n    console.log(\r\n      'dataV', dataV.byteLength,\r\n    )\r\n\r\n    if (dataV.byteLength > 44) {\r\n      Player.play(dataV.buffer);  // 播放\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取已经播放了多长时间\r\n   */\r\n  getPlayTime(): number {\r\n    return Player.getPlayTime();\r\n  }\r\n\r\n  /**\r\n   * 暂停播放录音\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  pausePlay(): void {\r\n    if (this.isrecording || !this.isplaying) {\r\n      // 正在录音或没有播放，暂停无效\r\n      return;\r\n    }\r\n\r\n    this.isplaying = false;\r\n    this.onpauseplay && this.onpauseplay();\r\n    Player.pausePlay();\r\n  }\r\n\r\n  /**\r\n   * 恢复播放录音\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  resumePlay(): void {\r\n    if (this.isrecording || this.isplaying) {\r\n      // 正在录音或已经播放或没开始播放，恢复无效\r\n      return;\r\n    }\r\n\r\n    this.isplaying = true;\r\n    this.onresumeplay && this.onresumeplay();\r\n    Player.resumePlay();\r\n  }\r\n\r\n  /**\r\n   * 停止播放\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  stopPlay(): void {\r\n    if (this.isrecording) {\r\n      // 正在录音，停止录音播放无效\r\n      return;\r\n    }\r\n\r\n    this.isplaying = false;\r\n    this.onstopplay && this.onstopplay();\r\n    Player.stopPlay();\r\n  }\r\n\r\n  destroy(): Promise<{}> {\r\n    Player.destroyPlay();\r\n\r\n    return this.destroyRecord();\r\n  }\r\n\r\n  /**\r\n   * 获取当前已经录音的PCM音频数据\r\n   *\r\n   * @returns[DataView]\r\n   * @memberof Recorder\r\n   */\r\n  // getWholeData() {\r\n  //     return this.tempPCM;\r\n  // }\r\n\r\n  /**\r\n   * 获取余下的新数据，不包括 getNextData 前一次获取的数据\r\n   *\r\n   * @returns [DataView]\r\n   * @memberof Recorder\r\n   */\r\n  getNextData() {\r\n    let length = this.tempPCM.length,\r\n      data = this.tempPCM.slice(this.offset);\r\n\r\n      console.log('this.offset', this.offset)\r\n\r\n    this.offset = length;\r\n\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * 获取当前录音的波形数据，\r\n   * 调取频率由外部控制。\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  getRecordAnalyseData(): any {\r\n    return this.getAnalyseData();\r\n  }\r\n\r\n  /**\r\n   * 获取录音播放时的波形数据，\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  getPlayAnalyseData(): any {\r\n    // 现在录音和播放不允许同时进行，所有复用的录音的analyser节点。\r\n    return Player.getAnalyseData();\r\n  }\r\n\r\n  getPCM(): any {\r\n    // 先停止\r\n    this.stop();\r\n    // 获取pcm数据\r\n    let data: any = this.getData();\r\n    // 根据输入输出比例 压缩或扩展\r\n    data = compress(data, this.inputSampleRate, this.outputSampleRate);\r\n    // 按采样位数重新编码\r\n    return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n  }\r\n\r\n  /**\r\n   * 获取PCM格式的blob数据\r\n   *\r\n   * @returns { blob }  PCM格式的blob数据\r\n   * @memberof Recorder\r\n   */\r\n  getPCMBlob(): any {\r\n    return new Blob([this.getPCM()]);\r\n  }\r\n\r\n  /**\r\n   * 下载录音pcm数据\r\n   *\r\n   * @param {string} [name='recorder']    重命名的名字\r\n   * @memberof Recorder\r\n   */\r\n  downloadPCM(name: string = 'recorder'): void {\r\n    let pcmBlob = this.getPCMBlob();\r\n\r\n    downloadPCM(pcmBlob, name);\r\n  }\r\n\r\n  /**\r\n   * 获取WAV编码的二进制数据(dataview)\r\n   *\r\n   * @returns {dataview}  WAV编码的二进制数据\r\n   * @memberof Recorder\r\n   */\r\n  getWAV(): any {\r\n    let pcmTemp = this.getPCM();\r\n\r\n    // PCM增加44字节的头就是WAV格式了\r\n    return encodeWAV(pcmTemp, this.inputSampleRate,\r\n      this.outputSampleRate, this.config.numChannels!, this.oututSampleBits, this.littleEdian);;\r\n  }\r\n\r\n  /**\r\n   * 获取WAV音频的blob数据\r\n   *\r\n   * @returns { blob }    wav格式blob数据\r\n   * @memberof Recorder\r\n   */\r\n  getWAVBlob(): any {\r\n    return new Blob([this.getWAV()], { type: 'audio/wav' });\r\n  }\r\n\r\n  /**\r\n   * 下载录音的wav数据\r\n   *\r\n   * @param {string} [name='recorder']    重命名的名字\r\n   * @memberof Recorder\r\n   */\r\n  downloadWAV(name: string = 'recorder'): void {\r\n    let wavBlob = this.getWAVBlob();\r\n\r\n    downloadWAV(wavBlob, name);\r\n  }\r\n\r\n  /**\r\n   * 通用的下载接口\r\n   */\r\n  download(blob: any, name: string, type: string): void {\r\n    download(blob, name, type);\r\n  }\r\n\r\n  /**\r\n   * 获取左和右声道的数据\r\n   *\r\n   * @returns [DataView]\r\n   */\r\n  getChannelData(): any {\r\n    const all = this.getPCM();\r\n    const length = all.byteLength;\r\n    const littleEdian = this.littleEdian\r\n    const res: { left: DataView | null, right: DataView | null } = { left: null, right: null }\r\n\r\n    if (this.config.numChannels === 2) {\r\n      // 双通道,劈开\r\n      const lD = new DataView(new ArrayBuffer(length / 2))\r\n      const rD = new DataView(new ArrayBuffer(length / 2))\r\n      // 双声道，需要拆分下数据\r\n\r\n      if (this.config.sampleBits === 16) {\r\n        for (var i = 0; i < length / 2; i += 2) {\r\n          lD.setInt16(i, all.getInt16(i * 2, littleEdian), littleEdian)\r\n          rD.setInt16(i, all.getInt16(i * 2 + 2, littleEdian), littleEdian)\r\n        }\r\n      } else {\r\n        for (var i = 0; i < length / 2; i += 2) {\r\n          lD.setInt8(i, all.getInt8(i * 2))\r\n          rD.setInt8(i, all.getInt8(i * 2 + 1))\r\n        }\r\n      }\r\n\r\n      res.left = lD\r\n      res.right = rD\r\n    } else {\r\n      // 单通道\r\n      res.left = all\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nexport default Index;\r\n"
        }
    ]
}