{
    "sourceFile": "src/core/recorder/recorder.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1681623584309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1681623892175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,10 @@\n   private size: number = 0;                       // 录音文件总长度\r\n   private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n   private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n   private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n-  private tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n+  public offset: number = 0\r\n+  public tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n   private audioInput: any;\r\n   protected inputSampleRate: number;              // 输入采样率\r\n   protected inputSampleBits: number = 16;         // 输入采样位数\r\n   protected outputSampleRate: number = 0;             // 输出采样率\r\n@@ -220,23 +221,24 @@\n     } else {\r\n       lData = new Float32Array(this.size / 2);\r\n       rData = new Float32Array(this.size / 2);\r\n     }\r\n-    // 合并\r\n-    let offset = 0; // 偏移量计算\r\n+    // // 合并\r\n+    // let offset = 0; // 偏移量计算\r\n \r\n     // 将二维数据，转成一维数据\r\n     // 左声道\r\n     for (let i = 0; i < this.lBuffer.length; i++) {\r\n-      lData.set(this.lBuffer[i], offset);\r\n-      offset += this.lBuffer[i].length;\r\n+      lData.set(this.lBuffer[i], this.offset);\r\n+      this.offset += this.lBuffer[i].length;\r\n     }\r\n \r\n-    offset = 0;\r\n+    // offset = 0;\r\n+    this.offset = 0\r\n     // 右声道\r\n     for (let i = 0; i < this.rBuffer.length; i++) {\r\n-      rData.set(this.rBuffer[i], offset);\r\n-      offset += this.rBuffer[i].length;\r\n+      rData.set(this.rBuffer[i], this.offset);\r\n+      this.offset += this.rBuffer[i].length;\r\n     }\r\n \r\n     return {\r\n       left: lData,\r\n@@ -284,15 +286,15 @@\n         this.size += rData.length;\r\n       }\r\n \r\n       // 边录边转处理 暂时不支持\r\n-      // if (this.config.compiling) {\r\n-      //     let pcm = this.transformIntoPCM(lData, rData);\r\n+      if (this.config.compiling) {\r\n+          let pcm = this.transformIntoPCM(lData, rData);\r\n \r\n-      //     this.tempPCM.push(pcm);\r\n-      //     // 计算录音大小\r\n-      //     this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n-      // } else {\r\n+          this.tempPCM.push(pcm);\r\n+          // 计算录音大小\r\n+          this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n+      } else {\r\n       // 计算录音大小\r\n       this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n         * (this.oututSampleBits / 8)\r\n       // }\r\n"
                },
                {
                    "date": 1681623902567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n    * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n    * @private\r\n    * @memberof Recorder\r\n    */\r\n-  private stopStream() {\r\n+  public stopStream() {\r\n     if (this.stream && this.stream.getTracks) {\r\n       this.stream.getTracks().forEach((track) => track.stop());\r\n       this.stream = null;\r\n     }\r\n"
                },
                {
                    "date": 1681624021974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -287,58 +287,60 @@\n       }\r\n \r\n       // 边录边转处理 暂时不支持\r\n       if (this.config.compiling) {\r\n-          let pcm = this.transformIntoPCM(lData, rData);\r\n+        let pcm = this.transformIntoPCM(lData, rData);\r\n \r\n-          this.tempPCM.push(pcm);\r\n-          // 计算录音大小\r\n-          this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n+        this.tempPCM.push(pcm);\r\n+        // 计算录音大小\r\n+        this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n       } else {\r\n-      // 计算录音大小\r\n-      this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n-        * (this.oututSampleBits / 8)\r\n-      // }\r\n-      // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n-      // 有小数位的偏差。\r\n+        // 计算录音大小\r\n+        this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n+          * (this.oututSampleBits / 8)\r\n+        // }\r\n+        // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n+        // 有小数位的偏差。\r\n \r\n-      // 计算音量百分比\r\n-      vol = Math.max.apply(Math, lData) * 100;\r\n-      // 统计录音时长\r\n-      this.duration += 4096 / this.inputSampleRate;\r\n-      // 录音时长回调\r\n-      this.onprocess && this.onprocess(this.duration);\r\n-      // 录音时长及响度回调\r\n-      this.onprogress && this.onprogress({\r\n-        duration: this.duration,\r\n-        fileSize: this.fileSize,\r\n-        vol,\r\n-        // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n-      });\r\n+        // 计算音量百分比\r\n+        vol = Math.max.apply(Math, lData) * 100;\r\n+        // 统计录音时长\r\n+        this.duration += 4096 / this.inputSampleRate;\r\n+        // 录音时长回调\r\n+        this.onprocess && this.onprocess(this.duration);\r\n+        // 录音时长及响度回调\r\n+        this.onprogress && this.onprogress({\r\n+          duration: this.duration,\r\n+          fileSize: this.fileSize,\r\n+          vol,\r\n+          // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n+        });\r\n+      }\r\n     }\r\n   }\r\n \r\n   /**\r\n    * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n    * @private\r\n    * @memberof Recorder\r\n    */\r\n-  public stopStream() {\r\n+  private stopStream() {\r\n     if (this.stream && this.stream.getTracks) {\r\n       this.stream.getTracks().forEach((track) => track.stop());\r\n       this.stream = null;\r\n     }\r\n   }\r\n \r\n+\r\n   /**\r\n    * close兼容方案\r\n    * 如firefox 30 等低版本浏览器没有 close方法\r\n    */\r\n   private closeAudioContext() {\r\n     if (this.context && this.context.close && this.context.state !== 'closed') {\r\n       return this.context.close();\r\n     } else {\r\n-      return  Promise.resolve();\r\n+      return Promise.resolve();\r\n       // return new Promise((resolve) => {\r\n       //   resolve();\r\n       // });\r\n     }\r\n@@ -359,9 +361,9 @@\n         if (!getUserMedia) {\r\n           return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n         }\r\n \r\n-        return new Promise((resolve, reject)  => {\r\n+        return new Promise((resolve, reject) => {\r\n           getUserMedia(navigator, constraints, resolve, reject);\r\n         });\r\n       }\r\n     }\r\n"
                },
                {
                    "date": 1681624297401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n         this.onprogress && this.onprogress({\r\n           duration: this.duration,\r\n           fileSize: this.fileSize,\r\n           vol,\r\n-          // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n+          data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n         });\r\n       }\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1681624345473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n         this.onprogress && this.onprogress({\r\n           duration: this.duration,\r\n           fileSize: this.fileSize,\r\n           vol,\r\n-          data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n+          // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n         });\r\n       }\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1681631837103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -286,8 +286,9 @@\n         this.size += rData.length;\r\n       }\r\n \r\n       // 边录边转处理 暂时不支持\r\n+      console.log('this.config.compiling', this.config.compiling)\r\n       if (this.config.compiling) {\r\n         let pcm = this.transformIntoPCM(lData, rData);\r\n \r\n         this.tempPCM.push(pcm);\r\n"
                },
                {
                    "date": 1681631888206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,9 @@\n       sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate!) ? options.sampleRate : this.inputSampleRate,\r\n       // 声道数，1或2\r\n       numChannels: ~[1, 2].indexOf(options.numChannels!) ? options.numChannels : 1,\r\n       // 是否需要边录边转，默认关闭，后期使用web worker\r\n-      // compiling: !!options.compiling || false,   // 先移除\r\n+      compiling: !!options.compiling || false,   // 先移除\r\n     };\r\n     // 设置采样的参数\r\n     this.outputSampleRate = this.config.sampleRate!;     // 输出采样率\r\n     this.oututSampleBits = this.config.sampleBits!;      // 输出采样数位 8, 16\r\n"
                },
                {
                    "date": 1681631924018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -289,9 +289,9 @@\n       // 边录边转处理 暂时不支持\r\n       console.log('this.config.compiling', this.config.compiling)\r\n       if (this.config.compiling) {\r\n         let pcm = this.transformIntoPCM(lData, rData);\r\n-\r\n+        console.log('pcm', pcm) \r\n         this.tempPCM.push(pcm);\r\n         // 计算录音大小\r\n         this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n       } else {\r\n"
                },
                {
                    "date": 1681631930220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,399 @@\n+import { Stream } from 'stream';\r\n+import { compress, encodePCM, encodeWAV } from '../transform/transform';\r\n+\r\n+declare let window: any;\r\n+declare let Math: any;\r\n+\r\n+// 构造函数参数格式\r\n+interface recorderConfig {\r\n+  sampleBits?: number,        // 采样位数\r\n+  sampleRate?: number,        // 采样率\r\n+  numChannels?: number,       // 声道数\r\n+  compiling?: boolean,        // 是否边录边播\r\n+}\r\n+\r\n+export default class Recorder {\r\n+  private context: any;\r\n+  protected config: recorderConfig = {};               // 配置\r\n+  private analyser: any;\r\n+  private size: number = 0;                       // 录音文件总长度\r\n+  private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n+  private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n+  private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n+  public offset: number = 0\r\n+  public tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n+  private audioInput: any;\r\n+  protected inputSampleRate: number;              // 输入采样率\r\n+  protected inputSampleBits: number = 16;         // 输入采样位数\r\n+  protected outputSampleRate: number = 0;             // 输出采样率\r\n+  protected oututSampleBits: number = 0;              // 输出采样位数\r\n+  private source: any;                            // 音频输入\r\n+  private recorder: any;\r\n+  private stream: MediaStream | null = null;                            // 流\r\n+  protected littleEdian: boolean;                 // 是否是小端字节序\r\n+  protected fileSize: number = 0;                 // 录音大小，byte为单位\r\n+  protected duration: number = 0;                 // 录音时长\r\n+  private needRecord: boolean = true;             // 由于safari问题，导致使用该方案代替disconnect/connect方案\r\n+  // 正在录音时间，参数是已经录了多少时间了\r\n+  // @ts-ignore\r\n+  public onprocess: (duration: number) => void;\r\n+  // onprocess 替代函数，保持原来的 onprocess 向下兼容\r\n+  // @ts-ignore\r\n+  public onprogress: (payload: {\r\n+    duration: number,\r\n+    fileSize: number,\r\n+    vol: number,\r\n+    // data: Array<DataView>,      // 当前存储的所有录音数据\r\n+  }) => void;\r\n+  // @ts-ignore\r\n+  public onplay: () => void;                  // 音频播放回调\r\n+  // @ts-ignore\r\n+  public onpauseplay: () => void;             // 音频暂停回调\r\n+  // @ts-ignore\r\n+  public onresumeplay: () => void;            // 音频恢复播放回调\r\n+  // @ts-ignore\r\n+  public onstopplay: () => void;              // 音频停止播放回调\r\n+  // @ts-ignore\r\n+  public onplayend: () => void;               // 音频正常播放结束\r\n+\r\n+  /**\r\n+   * @param {Object} options 包含以下三个参数：\r\n+   * sampleBits，采样位数，一般8,16，默认16\r\n+   * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n+   * numChannels，声道，1或2\r\n+   */\r\n+  constructor (options: recorderConfig = {}) {\r\n+    // 临时audioContext，为了获取输入采样率的\r\n+    let context = new (window.AudioContext || window.webkitAudioContext)();\r\n+\r\n+    this.inputSampleRate = context.sampleRate;     // 获取当前输入的采样率\r\n+\r\n+    // 设置输出配置\r\n+    this.setNewOption(options);\r\n+\r\n+    // 判断端字节序\r\n+    this.littleEdian = (function () {\r\n+      let buffer = new ArrayBuffer(2);\r\n+      new DataView(buffer).setInt16(0, 256, true);\r\n+      return new Int16Array(buffer)[0] === 256;\r\n+    })();\r\n+    // 兼容 getUserMedia\r\n+    Recorder.initUserMedia();\r\n+  }\r\n+\r\n+  protected setNewOption(options: recorderConfig = {}) {\r\n+    this.config = {\r\n+      // 采样数位 8, 16\r\n+      sampleBits: ~[8, 16].indexOf(options.sampleBits!) ? options.sampleBits : 16,\r\n+      // 采样率\r\n+      sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate!) ? options.sampleRate : this.inputSampleRate,\r\n+      // 声道数，1或2\r\n+      numChannels: ~[1, 2].indexOf(options.numChannels!) ? options.numChannels : 1,\r\n+      // 是否需要边录边转，默认关闭，后期使用web worker\r\n+      compiling: !!options.compiling || false,   // 先移除\r\n+    };\r\n+    // 设置采样的参数\r\n+    this.outputSampleRate = this.config.sampleRate!;     // 输出采样率\r\n+    this.oututSampleBits = this.config.sampleBits!;      // 输出采样数位 8, 16\r\n+  }\r\n+\r\n+  /**\r\n+   * 开始录音\r\n+   *\r\n+   * @returns {Promise<{}>}\r\n+   * @memberof Recorder\r\n+   */\r\n+  startRecord(): Promise<{}> {\r\n+    if (this.context) {\r\n+      // 关闭先前的录音实例，因为前次的实例会缓存少量前次的录音数据\r\n+      this.destroyRecord();\r\n+    }\r\n+    // 初始化\r\n+    this.initRecorder();\r\n+\r\n+    // @ts-ignore\r\n+    return navigator.mediaDevices.getUserMedia({\r\n+      audio: true\r\n+    }).then((stream: MediaStream) => {\r\n+      // audioInput表示音频源节点\r\n+      // stream是通过navigator.getUserMedia获取的外部（如麦克风）stream音频输出，对于这就是输入\r\n+      this.audioInput = this.context.createMediaStreamSource(stream);\r\n+      this.stream = stream;\r\n+    }/* 报错丢给外部使用者catch，后期可在此处增加建议性提示\r\n+            , error => {\r\n+            // 抛出异常\r\n+            Recorder.throwError(error.name + \" : \" + error.message);\r\n+        } */).then(() => {\r\n+      // audioInput 为声音源，连接到处理节点 recorder\r\n+      this.audioInput.connect(this.analyser);\r\n+      this.analyser.connect(this.recorder);\r\n+      // this.audioInput.connect(this.recorder);\r\n+      // 处理节点 recorder 连接到扬声器\r\n+      this.recorder.connect(this.context.destination);\r\n+    });\r\n+  }\r\n+\r\n+  /**\r\n+   * 暂停录音\r\n+   *\r\n+   * @memberof Recorder\r\n+   */\r\n+  pauseRecord(): void {\r\n+    this.needRecord = false;\r\n+  }\r\n+\r\n+  /**\r\n+   * 继续录音\r\n+   *\r\n+   * @memberof Recorder\r\n+   */\r\n+  resumeRecord(): void {\r\n+    this.needRecord = true;\r\n+  }\r\n+\r\n+  /**\r\n+   * 停止录音\r\n+   *\r\n+   */\r\n+  stopRecord(): void {\r\n+    this.audioInput && this.audioInput.disconnect();\r\n+    this.source && this.source.stop();\r\n+    this.recorder.disconnect();\r\n+    this.analyser.disconnect();\r\n+    this.needRecord = true;\r\n+  }\r\n+\r\n+  /**\r\n+   * 销毁录音对象\r\n+   *\r\n+   */\r\n+  destroyRecord(): Promise<{}> {\r\n+    this.clearRecordStatus();\r\n+    // 结束流\r\n+    this.stopStream();\r\n+\r\n+    return this.closeAudioContext();\r\n+  }\r\n+\r\n+  getAnalyseData() {\r\n+    let dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n+    // 将数据拷贝到dataArray中。\r\n+    this.analyser.getByteTimeDomainData(dataArray);\r\n+\r\n+    return dataArray;\r\n+  }\r\n+\r\n+  // 获取录音数据\r\n+  getData() {\r\n+    let data: any = this.flat();\r\n+\r\n+    return data;\r\n+  }\r\n+\r\n+  /**\r\n+   * 清除状态\r\n+   *\r\n+   */\r\n+  private clearRecordStatus() {\r\n+    this.lBuffer.length = 0;\r\n+    this.rBuffer.length = 0;\r\n+    this.size = 0;\r\n+    this.fileSize = 0;\r\n+    this.PCM = null;\r\n+    this.audioInput = null;\r\n+    this.duration = 0;\r\n+  }\r\n+\r\n+  /**\r\n+   * 将二维数组转一维\r\n+   *\r\n+   * @private\r\n+   * @returns  {float32array}     音频pcm二进制数据\r\n+   * @memberof Recorder\r\n+   */\r\n+  private flat() {\r\n+    let lData = null,\r\n+      rData = new Float32Array(0);    // 右声道默认为0\r\n+\r\n+    // 创建存放数据的容器\r\n+    if (1 === this.config.numChannels) {\r\n+      lData = new Float32Array(this.size);\r\n+    } else {\r\n+      lData = new Float32Array(this.size / 2);\r\n+      rData = new Float32Array(this.size / 2);\r\n+    }\r\n+    // // 合并\r\n+    // let offset = 0; // 偏移量计算\r\n+\r\n+    // 将二维数据，转成一维数据\r\n+    // 左声道\r\n+    for (let i = 0; i < this.lBuffer.length; i++) {\r\n+      lData.set(this.lBuffer[i], this.offset);\r\n+      this.offset += this.lBuffer[i].length;\r\n+    }\r\n+\r\n+    // offset = 0;\r\n+    this.offset = 0\r\n+    // 右声道\r\n+    for (let i = 0; i < this.rBuffer.length; i++) {\r\n+      rData.set(this.rBuffer[i], this.offset);\r\n+      this.offset += this.rBuffer[i].length;\r\n+    }\r\n+\r\n+    return {\r\n+      left: lData,\r\n+      right: rData\r\n+    };\r\n+  }\r\n+\r\n+  /**\r\n+   * 初始化录音实例\r\n+   */\r\n+  private initRecorder(): void {\r\n+    // 清空数据\r\n+    this.clearRecordStatus();\r\n+\r\n+    this.context = new (window.AudioContext || window.webkitAudioContext)();\r\n+\r\n+    this.analyser = this.context.createAnalyser();  // 录音分析节点\r\n+    this.analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n+\r\n+    // 第一个参数表示收集采样的大小，采集完这么多后会触发 onaudioprocess 接口一次，该值一般为1024,2048,4096等，一般就设置为4096\r\n+    // 第二，三个参数分别是输入的声道数和输出的声道数，保持一致即可。\r\n+    let createScript = this.context.createScriptProcessor || this.context.createJavaScriptNode;\r\n+    this.recorder = createScript.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]);\r\n+\r\n+    // 音频采集\r\n+    this.recorder.onaudioprocess = (e: any) => {\r\n+      if (!this.needRecord) {\r\n+        return;\r\n+      }\r\n+      // 左声道数据\r\n+      // getChannelData返回Float32Array类型的pcm数据\r\n+      let lData = e.inputBuffer.getChannelData(0),\r\n+        rData = null,\r\n+        vol = 0;        // 音量百分比\r\n+\r\n+      this.lBuffer.push(new Float32Array(lData));\r\n+\r\n+      this.size += lData.length;\r\n+\r\n+      // 判断是否有右声道数据\r\n+      if (2 === this.config.numChannels) {\r\n+        rData = e.inputBuffer.getChannelData(1);\r\n+        this.rBuffer.push(new Float32Array(rData));\r\n+\r\n+        this.size += rData.length;\r\n+      }\r\n+\r\n+      // 边录边转处理 暂时不支持\r\n+      if (this.config.compiling) {\r\n+        let pcm = this.transformIntoPCM(lData, rData);\r\n+        console.log('pcm', pcm) \r\n+        this.tempPCM.push(pcm);\r\n+        // 计算录音大小\r\n+        this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n+      } else {\r\n+        // 计算录音大小\r\n+        this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n+          * (this.oututSampleBits / 8)\r\n+        // }\r\n+        // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n+        // 有小数位的偏差。\r\n+\r\n+        // 计算音量百分比\r\n+        vol = Math.max.apply(Math, lData) * 100;\r\n+        // 统计录音时长\r\n+        this.duration += 4096 / this.inputSampleRate;\r\n+        // 录音时长回调\r\n+        this.onprocess && this.onprocess(this.duration);\r\n+        // 录音时长及响度回调\r\n+        this.onprogress && this.onprogress({\r\n+          duration: this.duration,\r\n+          fileSize: this.fileSize,\r\n+          vol,\r\n+          // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n+        });\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n+   * @private\r\n+   * @memberof Recorder\r\n+   */\r\n+  private stopStream() {\r\n+    if (this.stream && this.stream.getTracks) {\r\n+      this.stream.getTracks().forEach((track) => track.stop());\r\n+      this.stream = null;\r\n+    }\r\n+  }\r\n+\r\n+\r\n+  /**\r\n+   * close兼容方案\r\n+   * 如firefox 30 等低版本浏览器没有 close方法\r\n+   */\r\n+  private closeAudioContext() {\r\n+    if (this.context && this.context.close && this.context.state !== 'closed') {\r\n+      return this.context.close();\r\n+    } else {\r\n+      return Promise.resolve();\r\n+      // return new Promise((resolve) => {\r\n+      //   resolve();\r\n+      // });\r\n+    }\r\n+  }\r\n+\r\n+  // getUserMedia 版本兼容\r\n+  static initUserMedia() {\r\n+    if (navigator.mediaDevices === undefined) {\r\n+      // @ts-ignore\r\n+      navigator.mediaDevices = {};\r\n+    }\r\n+\r\n+    if (navigator.mediaDevices.getUserMedia === undefined) {\r\n+      navigator.mediaDevices.getUserMedia = function (constraints: any) {\r\n+        // @ts-ignore\r\n+        let getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n+\r\n+        if (!getUserMedia) {\r\n+          return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n+        }\r\n+\r\n+        return new Promise((resolve, reject) => {\r\n+          getUserMedia(navigator, constraints, resolve, reject);\r\n+        });\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * 将获取到到左右声道的Float32Array数据编码转化\r\n+   *\r\n+   * @param {Float32Array} lData  左声道数据\r\n+   * @param {Float32Array} rData  有声道数据\r\n+   * @returns DataView\r\n+   */\r\n+  private transformIntoPCM(lData: any, rData: any) {\r\n+    let lBuffer = new Float32Array(lData),\r\n+      rBuffer = new Float32Array(rData);\r\n+\r\n+    let data = compress({\r\n+      left: lBuffer,\r\n+      right: rBuffer,\r\n+    }, this.inputSampleRate, this.outputSampleRate);\r\n+\r\n+    return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n+  }\r\n+\r\n+  static getPermission(): Promise<{}> {\r\n+    this.initUserMedia();\r\n+\r\n+    // @ts-ignore\r\n+    return navigator.mediaDevices.getUserMedia({ audio: true }).then((stream: MediaStream) => {\r\n+      stream && stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n+    });\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1681632077452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -288,9 +288,8 @@\n \r\n       // 边录边转处理 暂时不支持\r\n       if (this.config.compiling) {\r\n         let pcm = this.transformIntoPCM(lData, rData);\r\n-        console.log('pcm', pcm) \r\n         this.tempPCM.push(pcm);\r\n         // 计算录音大小\r\n         this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n       } else {\r\n@@ -396,404 +395,4 @@\n       stream && stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n     });\r\n   }\r\n }\r\n-import { Stream } from 'stream';\r\n-import { compress, encodePCM, encodeWAV } from '../transform/transform';\r\n-\r\n-declare let window: any;\r\n-declare let Math: any;\r\n-\r\n-// 构造函数参数格式\r\n-interface recorderConfig {\r\n-  sampleBits?: number,        // 采样位数\r\n-  sampleRate?: number,        // 采样率\r\n-  numChannels?: number,       // 声道数\r\n-  compiling?: boolean,        // 是否边录边播\r\n-}\r\n-\r\n-export default class Recorder {\r\n-  private context: any;\r\n-  protected config: recorderConfig = {};               // 配置\r\n-  private analyser: any;\r\n-  private size: number = 0;                       // 录音文件总长度\r\n-  private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n-  private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n-  private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n-  public offset: number = 0\r\n-  public tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n-  private audioInput: any;\r\n-  protected inputSampleRate: number;              // 输入采样率\r\n-  protected inputSampleBits: number = 16;         // 输入采样位数\r\n-  protected outputSampleRate: number = 0;             // 输出采样率\r\n-  protected oututSampleBits: number = 0;              // 输出采样位数\r\n-  private source: any;                            // 音频输入\r\n-  private recorder: any;\r\n-  private stream: MediaStream | null = null;                            // 流\r\n-  protected littleEdian: boolean;                 // 是否是小端字节序\r\n-  protected fileSize: number = 0;                 // 录音大小，byte为单位\r\n-  protected duration: number = 0;                 // 录音时长\r\n-  private needRecord: boolean = true;             // 由于safari问题，导致使用该方案代替disconnect/connect方案\r\n-  // 正在录音时间，参数是已经录了多少时间了\r\n-  // @ts-ignore\r\n-  public onprocess: (duration: number) => void;\r\n-  // onprocess 替代函数，保持原来的 onprocess 向下兼容\r\n-  // @ts-ignore\r\n-  public onprogress: (payload: {\r\n-    duration: number,\r\n-    fileSize: number,\r\n-    vol: number,\r\n-    // data: Array<DataView>,      // 当前存储的所有录音数据\r\n-  }) => void;\r\n-  // @ts-ignore\r\n-  public onplay: () => void;                  // 音频播放回调\r\n-  // @ts-ignore\r\n-  public onpauseplay: () => void;             // 音频暂停回调\r\n-  // @ts-ignore\r\n-  public onresumeplay: () => void;            // 音频恢复播放回调\r\n-  // @ts-ignore\r\n-  public onstopplay: () => void;              // 音频停止播放回调\r\n-  // @ts-ignore\r\n-  public onplayend: () => void;               // 音频正常播放结束\r\n-\r\n-  /**\r\n-   * @param {Object} options 包含以下三个参数：\r\n-   * sampleBits，采样位数，一般8,16，默认16\r\n-   * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n-   * numChannels，声道，1或2\r\n-   */\r\n-  constructor (options: recorderConfig = {}) {\r\n-    // 临时audioContext，为了获取输入采样率的\r\n-    let context = new (window.AudioContext || window.webkitAudioContext)();\r\n-\r\n-    this.inputSampleRate = context.sampleRate;     // 获取当前输入的采样率\r\n-\r\n-    // 设置输出配置\r\n-    this.setNewOption(options);\r\n-\r\n-    // 判断端字节序\r\n-    this.littleEdian = (function () {\r\n-      let buffer = new ArrayBuffer(2);\r\n-      new DataView(buffer).setInt16(0, 256, true);\r\n-      return new Int16Array(buffer)[0] === 256;\r\n-    })();\r\n-    // 兼容 getUserMedia\r\n-    Recorder.initUserMedia();\r\n-  }\r\n-\r\n-  protected setNewOption(options: recorderConfig = {}) {\r\n-    this.config = {\r\n-      // 采样数位 8, 16\r\n-      sampleBits: ~[8, 16].indexOf(options.sampleBits!) ? options.sampleBits : 16,\r\n-      // 采样率\r\n-      sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate!) ? options.sampleRate : this.inputSampleRate,\r\n-      // 声道数，1或2\r\n-      numChannels: ~[1, 2].indexOf(options.numChannels!) ? options.numChannels : 1,\r\n-      // 是否需要边录边转，默认关闭，后期使用web worker\r\n-      compiling: !!options.compiling || false,   // 先移除\r\n-    };\r\n-    // 设置采样的参数\r\n-    this.outputSampleRate = this.config.sampleRate!;     // 输出采样率\r\n-    this.oututSampleBits = this.config.sampleBits!;      // 输出采样数位 8, 16\r\n-  }\r\n-\r\n-  /**\r\n-   * 开始录音\r\n-   *\r\n-   * @returns {Promise<{}>}\r\n-   * @memberof Recorder\r\n-   */\r\n-  startRecord(): Promise<{}> {\r\n-    if (this.context) {\r\n-      // 关闭先前的录音实例，因为前次的实例会缓存少量前次的录音数据\r\n-      this.destroyRecord();\r\n-    }\r\n-    // 初始化\r\n-    this.initRecorder();\r\n-\r\n-    // @ts-ignore\r\n-    return navigator.mediaDevices.getUserMedia({\r\n-      audio: true\r\n-    }).then((stream: MediaStream) => {\r\n-      // audioInput表示音频源节点\r\n-      // stream是通过navigator.getUserMedia获取的外部（如麦克风）stream音频输出，对于这就是输入\r\n-      this.audioInput = this.context.createMediaStreamSource(stream);\r\n-      this.stream = stream;\r\n-    }/* 报错丢给外部使用者catch，后期可在此处增加建议性提示\r\n-            , error => {\r\n-            // 抛出异常\r\n-            Recorder.throwError(error.name + \" : \" + error.message);\r\n-        } */).then(() => {\r\n-      // audioInput 为声音源，连接到处理节点 recorder\r\n-      this.audioInput.connect(this.analyser);\r\n-      this.analyser.connect(this.recorder);\r\n-      // this.audioInput.connect(this.recorder);\r\n-      // 处理节点 recorder 连接到扬声器\r\n-      this.recorder.connect(this.context.destination);\r\n-    });\r\n-  }\r\n-\r\n-  /**\r\n-   * 暂停录音\r\n-   *\r\n-   * @memberof Recorder\r\n-   */\r\n-  pauseRecord(): void {\r\n-    this.needRecord = false;\r\n-  }\r\n-\r\n-  /**\r\n-   * 继续录音\r\n-   *\r\n-   * @memberof Recorder\r\n-   */\r\n-  resumeRecord(): void {\r\n-    this.needRecord = true;\r\n-  }\r\n-\r\n-  /**\r\n-   * 停止录音\r\n-   *\r\n-   */\r\n-  stopRecord(): void {\r\n-    this.audioInput && this.audioInput.disconnect();\r\n-    this.source && this.source.stop();\r\n-    this.recorder.disconnect();\r\n-    this.analyser.disconnect();\r\n-    this.needRecord = true;\r\n-  }\r\n-\r\n-  /**\r\n-   * 销毁录音对象\r\n-   *\r\n-   */\r\n-  destroyRecord(): Promise<{}> {\r\n-    this.clearRecordStatus();\r\n-    // 结束流\r\n-    this.stopStream();\r\n-\r\n-    return this.closeAudioContext();\r\n-  }\r\n-\r\n-  getAnalyseData() {\r\n-    let dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n-    // 将数据拷贝到dataArray中。\r\n-    this.analyser.getByteTimeDomainData(dataArray);\r\n-\r\n-    return dataArray;\r\n-  }\r\n-\r\n-  // 获取录音数据\r\n-  getData() {\r\n-    let data: any = this.flat();\r\n-\r\n-    return data;\r\n-  }\r\n-\r\n-  /**\r\n-   * 清除状态\r\n-   *\r\n-   */\r\n-  private clearRecordStatus() {\r\n-    this.lBuffer.length = 0;\r\n-    this.rBuffer.length = 0;\r\n-    this.size = 0;\r\n-    this.fileSize = 0;\r\n-    this.PCM = null;\r\n-    this.audioInput = null;\r\n-    this.duration = 0;\r\n-  }\r\n-\r\n-  /**\r\n-   * 将二维数组转一维\r\n-   *\r\n-   * @private\r\n-   * @returns  {float32array}     音频pcm二进制数据\r\n-   * @memberof Recorder\r\n-   */\r\n-  private flat() {\r\n-    let lData = null,\r\n-      rData = new Float32Array(0);    // 右声道默认为0\r\n-\r\n-    // 创建存放数据的容器\r\n-    if (1 === this.config.numChannels) {\r\n-      lData = new Float32Array(this.size);\r\n-    } else {\r\n-      lData = new Float32Array(this.size / 2);\r\n-      rData = new Float32Array(this.size / 2);\r\n-    }\r\n-    // // 合并\r\n-    // let offset = 0; // 偏移量计算\r\n-\r\n-    // 将二维数据，转成一维数据\r\n-    // 左声道\r\n-    for (let i = 0; i < this.lBuffer.length; i++) {\r\n-      lData.set(this.lBuffer[i], this.offset);\r\n-      this.offset += this.lBuffer[i].length;\r\n-    }\r\n-\r\n-    // offset = 0;\r\n-    this.offset = 0\r\n-    // 右声道\r\n-    for (let i = 0; i < this.rBuffer.length; i++) {\r\n-      rData.set(this.rBuffer[i], this.offset);\r\n-      this.offset += this.rBuffer[i].length;\r\n-    }\r\n-\r\n-    return {\r\n-      left: lData,\r\n-      right: rData\r\n-    };\r\n-  }\r\n-\r\n-  /**\r\n-   * 初始化录音实例\r\n-   */\r\n-  private initRecorder(): void {\r\n-    // 清空数据\r\n-    this.clearRecordStatus();\r\n-\r\n-    this.context = new (window.AudioContext || window.webkitAudioContext)();\r\n-\r\n-    this.analyser = this.context.createAnalyser();  // 录音分析节点\r\n-    this.analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n-\r\n-    // 第一个参数表示收集采样的大小，采集完这么多后会触发 onaudioprocess 接口一次，该值一般为1024,2048,4096等，一般就设置为4096\r\n-    // 第二，三个参数分别是输入的声道数和输出的声道数，保持一致即可。\r\n-    let createScript = this.context.createScriptProcessor || this.context.createJavaScriptNode;\r\n-    this.recorder = createScript.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]);\r\n-\r\n-    // 音频采集\r\n-    this.recorder.onaudioprocess = (e: any) => {\r\n-      if (!this.needRecord) {\r\n-        return;\r\n-      }\r\n-      // 左声道数据\r\n-      // getChannelData返回Float32Array类型的pcm数据\r\n-      let lData = e.inputBuffer.getChannelData(0),\r\n-        rData = null,\r\n-        vol = 0;        // 音量百分比\r\n-\r\n-      this.lBuffer.push(new Float32Array(lData));\r\n-\r\n-      this.size += lData.length;\r\n-\r\n-      // 判断是否有右声道数据\r\n-      if (2 === this.config.numChannels) {\r\n-        rData = e.inputBuffer.getChannelData(1);\r\n-        this.rBuffer.push(new Float32Array(rData));\r\n-\r\n-        this.size += rData.length;\r\n-      }\r\n-\r\n-      // 边录边转处理 暂时不支持\r\n-      console.log('this.config.compiling', this.config.compiling)\r\n-      if (this.config.compiling) {\r\n-        let pcm = this.transformIntoPCM(lData, rData);\r\n-        console.log('pcm', pcm) \r\n-        this.tempPCM.push(pcm);\r\n-        // 计算录音大小\r\n-        this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n-      } else {\r\n-        // 计算录音大小\r\n-        this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n-          * (this.oututSampleBits / 8)\r\n-        // }\r\n-        // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n-        // 有小数位的偏差。\r\n-\r\n-        // 计算音量百分比\r\n-        vol = Math.max.apply(Math, lData) * 100;\r\n-        // 统计录音时长\r\n-        this.duration += 4096 / this.inputSampleRate;\r\n-        // 录音时长回调\r\n-        this.onprocess && this.onprocess(this.duration);\r\n-        // 录音时长及响度回调\r\n-        this.onprogress && this.onprogress({\r\n-          duration: this.duration,\r\n-          fileSize: this.fileSize,\r\n-          vol,\r\n-          // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n-        });\r\n-      }\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n-   * @private\r\n-   * @memberof Recorder\r\n-   */\r\n-  private stopStream() {\r\n-    if (this.stream && this.stream.getTracks) {\r\n-      this.stream.getTracks().forEach((track) => track.stop());\r\n-      this.stream = null;\r\n-    }\r\n-  }\r\n-\r\n-\r\n-  /**\r\n-   * close兼容方案\r\n-   * 如firefox 30 等低版本浏览器没有 close方法\r\n-   */\r\n-  private closeAudioContext() {\r\n-    if (this.context && this.context.close && this.context.state !== 'closed') {\r\n-      return this.context.close();\r\n-    } else {\r\n-      return Promise.resolve();\r\n-      // return new Promise((resolve) => {\r\n-      //   resolve();\r\n-      // });\r\n-    }\r\n-  }\r\n-\r\n-  // getUserMedia 版本兼容\r\n-  static initUserMedia() {\r\n-    if (navigator.mediaDevices === undefined) {\r\n-      // @ts-ignore\r\n-      navigator.mediaDevices = {};\r\n-    }\r\n-\r\n-    if (navigator.mediaDevices.getUserMedia === undefined) {\r\n-      navigator.mediaDevices.getUserMedia = function (constraints: any) {\r\n-        // @ts-ignore\r\n-        let getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n-\r\n-        if (!getUserMedia) {\r\n-          return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n-        }\r\n-\r\n-        return new Promise((resolve, reject) => {\r\n-          getUserMedia(navigator, constraints, resolve, reject);\r\n-        });\r\n-      }\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * 将获取到到左右声道的Float32Array数据编码转化\r\n-   *\r\n-   * @param {Float32Array} lData  左声道数据\r\n-   * @param {Float32Array} rData  有声道数据\r\n-   * @returns DataView\r\n-   */\r\n-  private transformIntoPCM(lData: any, rData: any) {\r\n-    let lBuffer = new Float32Array(lData),\r\n-      rBuffer = new Float32Array(rData);\r\n-\r\n-    let data = compress({\r\n-      left: lBuffer,\r\n-      right: rBuffer,\r\n-    }, this.inputSampleRate, this.outputSampleRate);\r\n-\r\n-    return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n-  }\r\n-\r\n-  static getPermission(): Promise<{}> {\r\n-    this.initUserMedia();\r\n-\r\n-    // @ts-ignore\r\n-    return navigator.mediaDevices.getUserMedia({ audio: true }).then((stream: MediaStream) => {\r\n-      stream && stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n-    });\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1681647632797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,398 @@\n+// import { Stream } from 'stream';\r\n+import { compress, encodePCM, encodeWAV } from '../transform/transform';\r\n+\r\n+declare let window: any;\r\n+declare let Math: any;\r\n+\r\n+// 构造函数参数格式\r\n+interface recorderConfig {\r\n+  sampleBits?: number,        // 采样位数\r\n+  sampleRate?: number,        // 采样率\r\n+  numChannels?: number,       // 声道数\r\n+  compiling?: boolean,        // 是否边录边播\r\n+}\r\n+\r\n+export default class Recorder {\r\n+  private context: any;\r\n+  protected config: recorderConfig = {};               // 配置\r\n+  private analyser: any;\r\n+  private size: number = 0;                       // 录音文件总长度\r\n+  private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n+  private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n+  private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n+  public offset: number = 0\r\n+  public tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n+  private audioInput: any;\r\n+  protected inputSampleRate: number;              // 输入采样率\r\n+  protected inputSampleBits: number = 16;         // 输入采样位数\r\n+  protected outputSampleRate: number = 0;             // 输出采样率\r\n+  protected oututSampleBits: number = 0;              // 输出采样位数\r\n+  private source: any;                            // 音频输入\r\n+  private recorder: any;\r\n+  private stream: MediaStream | null = null;                            // 流\r\n+  protected littleEdian: boolean;                 // 是否是小端字节序\r\n+  protected fileSize: number = 0;                 // 录音大小，byte为单位\r\n+  protected duration: number = 0;                 // 录音时长\r\n+  private needRecord: boolean = true;             // 由于safari问题，导致使用该方案代替disconnect/connect方案\r\n+  // 正在录音时间，参数是已经录了多少时间了\r\n+  // @ts-ignore\r\n+  public onprocess: (duration: number) => void;\r\n+  // onprocess 替代函数，保持原来的 onprocess 向下兼容\r\n+  // @ts-ignore\r\n+  public onprogress: (payload: {\r\n+    duration: number,\r\n+    fileSize: number,\r\n+    vol: number,\r\n+    // data: Array<DataView>,      // 当前存储的所有录音数据\r\n+  }) => void;\r\n+  // @ts-ignore\r\n+  public onplay: () => void;                  // 音频播放回调\r\n+  // @ts-ignore\r\n+  public onpauseplay: () => void;             // 音频暂停回调\r\n+  // @ts-ignore\r\n+  public onresumeplay: () => void;            // 音频恢复播放回调\r\n+  // @ts-ignore\r\n+  public onstopplay: () => void;              // 音频停止播放回调\r\n+  // @ts-ignore\r\n+  public onplayend: () => void;               // 音频正常播放结束\r\n+\r\n+  /**\r\n+   * @param {Object} options 包含以下三个参数：\r\n+   * sampleBits，采样位数，一般8,16，默认16\r\n+   * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n+   * numChannels，声道，1或2\r\n+   */\r\n+  constructor (options: recorderConfig = {}) {\r\n+    // 临时audioContext，为了获取输入采样率的\r\n+    let context = new (window.AudioContext || window.webkitAudioContext)();\r\n+\r\n+    this.inputSampleRate = context.sampleRate;     // 获取当前输入的采样率\r\n+\r\n+    // 设置输出配置\r\n+    this.setNewOption(options);\r\n+\r\n+    // 判断端字节序\r\n+    this.littleEdian = (function () {\r\n+      let buffer = new ArrayBuffer(2);\r\n+      new DataView(buffer).setInt16(0, 256, true);\r\n+      return new Int16Array(buffer)[0] === 256;\r\n+    })();\r\n+    // 兼容 getUserMedia\r\n+    Recorder.initUserMedia();\r\n+  }\r\n+\r\n+  protected setNewOption(options: recorderConfig = {}) {\r\n+    this.config = {\r\n+      // 采样数位 8, 16\r\n+      sampleBits: ~[8, 16].indexOf(options.sampleBits!) ? options.sampleBits : 16,\r\n+      // 采样率\r\n+      sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate!) ? options.sampleRate : this.inputSampleRate,\r\n+      // 声道数，1或2\r\n+      numChannels: ~[1, 2].indexOf(options.numChannels!) ? options.numChannels : 1,\r\n+      // 是否需要边录边转，默认关闭，后期使用web worker\r\n+      compiling: !!options.compiling || false,   // 先移除\r\n+    };\r\n+    // 设置采样的参数\r\n+    this.outputSampleRate = this.config.sampleRate!;     // 输出采样率\r\n+    this.oututSampleBits = this.config.sampleBits!;      // 输出采样数位 8, 16\r\n+  }\r\n+\r\n+  /**\r\n+   * 开始录音\r\n+   *\r\n+   * @returns {Promise<{}>}\r\n+   * @memberof Recorder\r\n+   */\r\n+  startRecord(): Promise<{}> {\r\n+    if (this.context) {\r\n+      // 关闭先前的录音实例，因为前次的实例会缓存少量前次的录音数据\r\n+      this.destroyRecord();\r\n+    }\r\n+    // 初始化\r\n+    this.initRecorder();\r\n+\r\n+    // @ts-ignore\r\n+    return navigator.mediaDevices.getUserMedia({\r\n+      audio: true\r\n+    }).then((stream: MediaStream) => {\r\n+      // audioInput表示音频源节点\r\n+      // stream是通过navigator.getUserMedia获取的外部（如麦克风）stream音频输出，对于这就是输入\r\n+      this.audioInput = this.context.createMediaStreamSource(stream);\r\n+      this.stream = stream;\r\n+    }/* 报错丢给外部使用者catch，后期可在此处增加建议性提示\r\n+            , error => {\r\n+            // 抛出异常\r\n+            Recorder.throwError(error.name + \" : \" + error.message);\r\n+        } */).then(() => {\r\n+      // audioInput 为声音源，连接到处理节点 recorder\r\n+      this.audioInput.connect(this.analyser);\r\n+      this.analyser.connect(this.recorder);\r\n+      // this.audioInput.connect(this.recorder);\r\n+      // 处理节点 recorder 连接到扬声器\r\n+      this.recorder.connect(this.context.destination);\r\n+    });\r\n+  }\r\n+\r\n+  /**\r\n+   * 暂停录音\r\n+   *\r\n+   * @memberof Recorder\r\n+   */\r\n+  pauseRecord(): void {\r\n+    this.needRecord = false;\r\n+  }\r\n+\r\n+  /**\r\n+   * 继续录音\r\n+   *\r\n+   * @memberof Recorder\r\n+   */\r\n+  resumeRecord(): void {\r\n+    this.needRecord = true;\r\n+  }\r\n+\r\n+  /**\r\n+   * 停止录音\r\n+   *\r\n+   */\r\n+  stopRecord(): void {\r\n+    this.audioInput && this.audioInput.disconnect();\r\n+    this.source && this.source.stop();\r\n+    this.recorder.disconnect();\r\n+    this.analyser.disconnect();\r\n+    this.needRecord = true;\r\n+  }\r\n+\r\n+  /**\r\n+   * 销毁录音对象\r\n+   *\r\n+   */\r\n+  destroyRecord(): Promise<{}> {\r\n+    this.clearRecordStatus();\r\n+    // 结束流\r\n+    this.stopStream();\r\n+\r\n+    return this.closeAudioContext();\r\n+  }\r\n+\r\n+  getAnalyseData() {\r\n+    let dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n+    // 将数据拷贝到dataArray中。\r\n+    this.analyser.getByteTimeDomainData(dataArray);\r\n+\r\n+    return dataArray;\r\n+  }\r\n+\r\n+  // 获取录音数据\r\n+  getData() {\r\n+    let data: any = this.flat();\r\n+\r\n+    return data;\r\n+  }\r\n+\r\n+  /**\r\n+   * 清除状态\r\n+   *\r\n+   */\r\n+  private clearRecordStatus() {\r\n+    this.lBuffer.length = 0;\r\n+    this.rBuffer.length = 0;\r\n+    this.size = 0;\r\n+    this.fileSize = 0;\r\n+    this.PCM = null;\r\n+    this.audioInput = null;\r\n+    this.duration = 0;\r\n+  }\r\n+\r\n+  /**\r\n+   * 将二维数组转一维\r\n+   *\r\n+   * @private\r\n+   * @returns  {float32array}     音频pcm二进制数据\r\n+   * @memberof Recorder\r\n+   */\r\n+  private flat() {\r\n+    let lData = null,\r\n+      rData = new Float32Array(0);    // 右声道默认为0\r\n+\r\n+    // 创建存放数据的容器\r\n+    if (1 === this.config.numChannels) {\r\n+      lData = new Float32Array(this.size);\r\n+    } else {\r\n+      lData = new Float32Array(this.size / 2);\r\n+      rData = new Float32Array(this.size / 2);\r\n+    }\r\n+    // // 合并\r\n+    // let offset = 0; // 偏移量计算\r\n+\r\n+    // 将二维数据，转成一维数据\r\n+    // 左声道\r\n+    for (let i = 0; i < this.lBuffer.length; i++) {\r\n+      lData.set(this.lBuffer[i], this.offset);\r\n+      this.offset += this.lBuffer[i].length;\r\n+    }\r\n+\r\n+    // offset = 0;\r\n+    this.offset = 0\r\n+    // 右声道\r\n+    for (let i = 0; i < this.rBuffer.length; i++) {\r\n+      rData.set(this.rBuffer[i], this.offset);\r\n+      this.offset += this.rBuffer[i].length;\r\n+    }\r\n+\r\n+    return {\r\n+      left: lData,\r\n+      right: rData\r\n+    };\r\n+  }\r\n+\r\n+  /**\r\n+   * 初始化录音实例\r\n+   */\r\n+  private initRecorder(): void {\r\n+    // 清空数据\r\n+    this.clearRecordStatus();\r\n+\r\n+    this.context = new (window.AudioContext || window.webkitAudioContext)();\r\n+\r\n+    this.analyser = this.context.createAnalyser();  // 录音分析节点\r\n+    this.analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n+\r\n+    // 第一个参数表示收集采样的大小，采集完这么多后会触发 onaudioprocess 接口一次，该值一般为1024,2048,4096等，一般就设置为4096\r\n+    // 第二，三个参数分别是输入的声道数和输出的声道数，保持一致即可。\r\n+    let createScript = this.context.createScriptProcessor || this.context.createJavaScriptNode;\r\n+    this.recorder = createScript.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]);\r\n+\r\n+    // 音频采集\r\n+    this.recorder.onaudioprocess = (e: any) => {\r\n+      if (!this.needRecord) {\r\n+        return;\r\n+      }\r\n+      // 左声道数据\r\n+      // getChannelData返回Float32Array类型的pcm数据\r\n+      let lData = e.inputBuffer.getChannelData(0),\r\n+        rData = null,\r\n+        vol = 0;        // 音量百分比\r\n+\r\n+      this.lBuffer.push(new Float32Array(lData));\r\n+\r\n+      this.size += lData.length;\r\n+\r\n+      // 判断是否有右声道数据\r\n+      if (2 === this.config.numChannels) {\r\n+        rData = e.inputBuffer.getChannelData(1);\r\n+        this.rBuffer.push(new Float32Array(rData));\r\n+\r\n+        this.size += rData.length;\r\n+      }\r\n+\r\n+      // 边录边转处理 暂时不支持\r\n+      if (this.config.compiling) {\r\n+        let pcm = this.transformIntoPCM(lData, rData);\r\n+        this.tempPCM.push(pcm);\r\n+        // 计算录音大小\r\n+        this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n+      } else {\r\n+        // 计算录音大小\r\n+        this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n+          * (this.oututSampleBits / 8)\r\n+        // }\r\n+        // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n+        // 有小数位的偏差。\r\n+\r\n+        // 计算音量百分比\r\n+        vol = Math.max.apply(Math, lData) * 100;\r\n+        // 统计录音时长\r\n+        this.duration += 4096 / this.inputSampleRate;\r\n+        // 录音时长回调\r\n+        this.onprocess && this.onprocess(this.duration);\r\n+        // 录音时长及响度回调\r\n+        this.onprogress && this.onprogress({\r\n+          duration: this.duration,\r\n+          fileSize: this.fileSize,\r\n+          vol,\r\n+          // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n+        });\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n+   * @private\r\n+   * @memberof Recorder\r\n+   */\r\n+  private stopStream() {\r\n+    if (this.stream && this.stream.getTracks) {\r\n+      this.stream.getTracks().forEach((track) => track.stop());\r\n+      this.stream = null;\r\n+    }\r\n+  }\r\n+\r\n+\r\n+  /**\r\n+   * close兼容方案\r\n+   * 如firefox 30 等低版本浏览器没有 close方法\r\n+   */\r\n+  private closeAudioContext() {\r\n+    if (this.context && this.context.close && this.context.state !== 'closed') {\r\n+      return this.context.close();\r\n+    } else {\r\n+      return Promise.resolve();\r\n+      // return new Promise((resolve) => {\r\n+      //   resolve();\r\n+      // });\r\n+    }\r\n+  }\r\n+\r\n+  // getUserMedia 版本兼容\r\n+  static initUserMedia() {\r\n+    if (navigator.mediaDevices === undefined) {\r\n+      // @ts-ignore\r\n+      navigator.mediaDevices = {};\r\n+    }\r\n+\r\n+    if (navigator.mediaDevices.getUserMedia === undefined) {\r\n+      navigator.mediaDevices.getUserMedia = function (constraints: any) {\r\n+        // @ts-ignore\r\n+        let getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n+\r\n+        if (!getUserMedia) {\r\n+          return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n+        }\r\n+\r\n+        return new Promise((resolve, reject) => {\r\n+          getUserMedia(navigator, constraints, resolve, reject);\r\n+        });\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * 将获取到到左右声道的Float32Array数据编码转化\r\n+   *\r\n+   * @param {Float32Array} lData  左声道数据\r\n+   * @param {Float32Array} rData  有声道数据\r\n+   * @returns DataView\r\n+   */\r\n+  private transformIntoPCM(lData: any, rData: any) {\r\n+    let lBuffer = new Float32Array(lData),\r\n+      rBuffer = new Float32Array(rData);\r\n+\r\n+    let data = compress({\r\n+      left: lBuffer,\r\n+      right: rBuffer,\r\n+    }, this.inputSampleRate, this.outputSampleRate);\r\n+\r\n+    return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n+  }\r\n+\r\n+  static getPermission(): Promise<{}> {\r\n+    this.initUserMedia();\r\n+\r\n+    // @ts-ignore\r\n+    return navigator.mediaDevices.getUserMedia({ audio: true }).then((stream: MediaStream) => {\r\n+      stream && stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n+    });\r\n+  }\r\n+}\r\n"
                }
            ],
            "date": 1681623584308,
            "name": "Commit-0",
            "content": "import { Stream } from 'stream';\r\nimport { compress, encodePCM, encodeWAV } from '../transform/transform';\r\n\r\ndeclare let window: any;\r\ndeclare let Math: any;\r\n\r\n// 构造函数参数格式\r\ninterface recorderConfig {\r\n  sampleBits?: number,        // 采样位数\r\n  sampleRate?: number,        // 采样率\r\n  numChannels?: number,       // 声道数\r\n  compiling?: boolean,        // 是否边录边播\r\n}\r\n\r\nexport default class Recorder {\r\n  private context: any;\r\n  protected config: recorderConfig = {};               // 配置\r\n  private analyser: any;\r\n  private size: number = 0;                       // 录音文件总长度\r\n  private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n  private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n  private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n  private tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n  private audioInput: any;\r\n  protected inputSampleRate: number;              // 输入采样率\r\n  protected inputSampleBits: number = 16;         // 输入采样位数\r\n  protected outputSampleRate: number = 0;             // 输出采样率\r\n  protected oututSampleBits: number = 0;              // 输出采样位数\r\n  private source: any;                            // 音频输入\r\n  private recorder: any;\r\n  private stream: MediaStream | null = null;                            // 流\r\n  protected littleEdian: boolean;                 // 是否是小端字节序\r\n  protected fileSize: number = 0;                 // 录音大小，byte为单位\r\n  protected duration: number = 0;                 // 录音时长\r\n  private needRecord: boolean = true;             // 由于safari问题，导致使用该方案代替disconnect/connect方案\r\n  // 正在录音时间，参数是已经录了多少时间了\r\n  // @ts-ignore\r\n  public onprocess: (duration: number) => void;\r\n  // onprocess 替代函数，保持原来的 onprocess 向下兼容\r\n  // @ts-ignore\r\n  public onprogress: (payload: {\r\n    duration: number,\r\n    fileSize: number,\r\n    vol: number,\r\n    // data: Array<DataView>,      // 当前存储的所有录音数据\r\n  }) => void;\r\n  // @ts-ignore\r\n  public onplay: () => void;                  // 音频播放回调\r\n  // @ts-ignore\r\n  public onpauseplay: () => void;             // 音频暂停回调\r\n  // @ts-ignore\r\n  public onresumeplay: () => void;            // 音频恢复播放回调\r\n  // @ts-ignore\r\n  public onstopplay: () => void;              // 音频停止播放回调\r\n  // @ts-ignore\r\n  public onplayend: () => void;               // 音频正常播放结束\r\n\r\n  /**\r\n   * @param {Object} options 包含以下三个参数：\r\n   * sampleBits，采样位数，一般8,16，默认16\r\n   * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n   * numChannels，声道，1或2\r\n   */\r\n  constructor (options: recorderConfig = {}) {\r\n    // 临时audioContext，为了获取输入采样率的\r\n    let context = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n    this.inputSampleRate = context.sampleRate;     // 获取当前输入的采样率\r\n\r\n    // 设置输出配置\r\n    this.setNewOption(options);\r\n\r\n    // 判断端字节序\r\n    this.littleEdian = (function () {\r\n      let buffer = new ArrayBuffer(2);\r\n      new DataView(buffer).setInt16(0, 256, true);\r\n      return new Int16Array(buffer)[0] === 256;\r\n    })();\r\n    // 兼容 getUserMedia\r\n    Recorder.initUserMedia();\r\n  }\r\n\r\n  protected setNewOption(options: recorderConfig = {}) {\r\n    this.config = {\r\n      // 采样数位 8, 16\r\n      sampleBits: ~[8, 16].indexOf(options.sampleBits!) ? options.sampleBits : 16,\r\n      // 采样率\r\n      sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate!) ? options.sampleRate : this.inputSampleRate,\r\n      // 声道数，1或2\r\n      numChannels: ~[1, 2].indexOf(options.numChannels!) ? options.numChannels : 1,\r\n      // 是否需要边录边转，默认关闭，后期使用web worker\r\n      // compiling: !!options.compiling || false,   // 先移除\r\n    };\r\n    // 设置采样的参数\r\n    this.outputSampleRate = this.config.sampleRate!;     // 输出采样率\r\n    this.oututSampleBits = this.config.sampleBits!;      // 输出采样数位 8, 16\r\n  }\r\n\r\n  /**\r\n   * 开始录音\r\n   *\r\n   * @returns {Promise<{}>}\r\n   * @memberof Recorder\r\n   */\r\n  startRecord(): Promise<{}> {\r\n    if (this.context) {\r\n      // 关闭先前的录音实例，因为前次的实例会缓存少量前次的录音数据\r\n      this.destroyRecord();\r\n    }\r\n    // 初始化\r\n    this.initRecorder();\r\n\r\n    // @ts-ignore\r\n    return navigator.mediaDevices.getUserMedia({\r\n      audio: true\r\n    }).then((stream: MediaStream) => {\r\n      // audioInput表示音频源节点\r\n      // stream是通过navigator.getUserMedia获取的外部（如麦克风）stream音频输出，对于这就是输入\r\n      this.audioInput = this.context.createMediaStreamSource(stream);\r\n      this.stream = stream;\r\n    }/* 报错丢给外部使用者catch，后期可在此处增加建议性提示\r\n            , error => {\r\n            // 抛出异常\r\n            Recorder.throwError(error.name + \" : \" + error.message);\r\n        } */).then(() => {\r\n      // audioInput 为声音源，连接到处理节点 recorder\r\n      this.audioInput.connect(this.analyser);\r\n      this.analyser.connect(this.recorder);\r\n      // this.audioInput.connect(this.recorder);\r\n      // 处理节点 recorder 连接到扬声器\r\n      this.recorder.connect(this.context.destination);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 暂停录音\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  pauseRecord(): void {\r\n    this.needRecord = false;\r\n  }\r\n\r\n  /**\r\n   * 继续录音\r\n   *\r\n   * @memberof Recorder\r\n   */\r\n  resumeRecord(): void {\r\n    this.needRecord = true;\r\n  }\r\n\r\n  /**\r\n   * 停止录音\r\n   *\r\n   */\r\n  stopRecord(): void {\r\n    this.audioInput && this.audioInput.disconnect();\r\n    this.source && this.source.stop();\r\n    this.recorder.disconnect();\r\n    this.analyser.disconnect();\r\n    this.needRecord = true;\r\n  }\r\n\r\n  /**\r\n   * 销毁录音对象\r\n   *\r\n   */\r\n  destroyRecord(): Promise<{}> {\r\n    this.clearRecordStatus();\r\n    // 结束流\r\n    this.stopStream();\r\n\r\n    return this.closeAudioContext();\r\n  }\r\n\r\n  getAnalyseData() {\r\n    let dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n    // 将数据拷贝到dataArray中。\r\n    this.analyser.getByteTimeDomainData(dataArray);\r\n\r\n    return dataArray;\r\n  }\r\n\r\n  // 获取录音数据\r\n  getData() {\r\n    let data: any = this.flat();\r\n\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * 清除状态\r\n   *\r\n   */\r\n  private clearRecordStatus() {\r\n    this.lBuffer.length = 0;\r\n    this.rBuffer.length = 0;\r\n    this.size = 0;\r\n    this.fileSize = 0;\r\n    this.PCM = null;\r\n    this.audioInput = null;\r\n    this.duration = 0;\r\n  }\r\n\r\n  /**\r\n   * 将二维数组转一维\r\n   *\r\n   * @private\r\n   * @returns  {float32array}     音频pcm二进制数据\r\n   * @memberof Recorder\r\n   */\r\n  private flat() {\r\n    let lData = null,\r\n      rData = new Float32Array(0);    // 右声道默认为0\r\n\r\n    // 创建存放数据的容器\r\n    if (1 === this.config.numChannels) {\r\n      lData = new Float32Array(this.size);\r\n    } else {\r\n      lData = new Float32Array(this.size / 2);\r\n      rData = new Float32Array(this.size / 2);\r\n    }\r\n    // 合并\r\n    let offset = 0; // 偏移量计算\r\n\r\n    // 将二维数据，转成一维数据\r\n    // 左声道\r\n    for (let i = 0; i < this.lBuffer.length; i++) {\r\n      lData.set(this.lBuffer[i], offset);\r\n      offset += this.lBuffer[i].length;\r\n    }\r\n\r\n    offset = 0;\r\n    // 右声道\r\n    for (let i = 0; i < this.rBuffer.length; i++) {\r\n      rData.set(this.rBuffer[i], offset);\r\n      offset += this.rBuffer[i].length;\r\n    }\r\n\r\n    return {\r\n      left: lData,\r\n      right: rData\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 初始化录音实例\r\n   */\r\n  private initRecorder(): void {\r\n    // 清空数据\r\n    this.clearRecordStatus();\r\n\r\n    this.context = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n    this.analyser = this.context.createAnalyser();  // 录音分析节点\r\n    this.analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n\r\n    // 第一个参数表示收集采样的大小，采集完这么多后会触发 onaudioprocess 接口一次，该值一般为1024,2048,4096等，一般就设置为4096\r\n    // 第二，三个参数分别是输入的声道数和输出的声道数，保持一致即可。\r\n    let createScript = this.context.createScriptProcessor || this.context.createJavaScriptNode;\r\n    this.recorder = createScript.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]);\r\n\r\n    // 音频采集\r\n    this.recorder.onaudioprocess = (e: any) => {\r\n      if (!this.needRecord) {\r\n        return;\r\n      }\r\n      // 左声道数据\r\n      // getChannelData返回Float32Array类型的pcm数据\r\n      let lData = e.inputBuffer.getChannelData(0),\r\n        rData = null,\r\n        vol = 0;        // 音量百分比\r\n\r\n      this.lBuffer.push(new Float32Array(lData));\r\n\r\n      this.size += lData.length;\r\n\r\n      // 判断是否有右声道数据\r\n      if (2 === this.config.numChannels) {\r\n        rData = e.inputBuffer.getChannelData(1);\r\n        this.rBuffer.push(new Float32Array(rData));\r\n\r\n        this.size += rData.length;\r\n      }\r\n\r\n      // 边录边转处理 暂时不支持\r\n      // if (this.config.compiling) {\r\n      //     let pcm = this.transformIntoPCM(lData, rData);\r\n\r\n      //     this.tempPCM.push(pcm);\r\n      //     // 计算录音大小\r\n      //     this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n      // } else {\r\n      // 计算录音大小\r\n      this.fileSize = Math.floor(this.size / Math.max(this.inputSampleRate / this.outputSampleRate, 1))\r\n        * (this.oututSampleBits / 8)\r\n      // }\r\n      // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n      // 有小数位的偏差。\r\n\r\n      // 计算音量百分比\r\n      vol = Math.max.apply(Math, lData) * 100;\r\n      // 统计录音时长\r\n      this.duration += 4096 / this.inputSampleRate;\r\n      // 录音时长回调\r\n      this.onprocess && this.onprocess(this.duration);\r\n      // 录音时长及响度回调\r\n      this.onprogress && this.onprogress({\r\n        duration: this.duration,\r\n        fileSize: this.fileSize,\r\n        vol,\r\n        // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n   * @private\r\n   * @memberof Recorder\r\n   */\r\n  private stopStream() {\r\n    if (this.stream && this.stream.getTracks) {\r\n      this.stream.getTracks().forEach((track) => track.stop());\r\n      this.stream = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * close兼容方案\r\n   * 如firefox 30 等低版本浏览器没有 close方法\r\n   */\r\n  private closeAudioContext() {\r\n    if (this.context && this.context.close && this.context.state !== 'closed') {\r\n      return this.context.close();\r\n    } else {\r\n      return  Promise.resolve();\r\n      // return new Promise((resolve) => {\r\n      //   resolve();\r\n      // });\r\n    }\r\n  }\r\n\r\n  // getUserMedia 版本兼容\r\n  static initUserMedia() {\r\n    if (navigator.mediaDevices === undefined) {\r\n      // @ts-ignore\r\n      navigator.mediaDevices = {};\r\n    }\r\n\r\n    if (navigator.mediaDevices.getUserMedia === undefined) {\r\n      navigator.mediaDevices.getUserMedia = function (constraints: any) {\r\n        // @ts-ignore\r\n        let getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n\r\n        if (!getUserMedia) {\r\n          return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n        }\r\n\r\n        return new Promise((resolve, reject)  => {\r\n          getUserMedia(navigator, constraints, resolve, reject);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 将获取到到左右声道的Float32Array数据编码转化\r\n   *\r\n   * @param {Float32Array} lData  左声道数据\r\n   * @param {Float32Array} rData  有声道数据\r\n   * @returns DataView\r\n   */\r\n  private transformIntoPCM(lData: any, rData: any) {\r\n    let lBuffer = new Float32Array(lData),\r\n      rBuffer = new Float32Array(rData);\r\n\r\n    let data = compress({\r\n      left: lBuffer,\r\n      right: rBuffer,\r\n    }, this.inputSampleRate, this.outputSampleRate);\r\n\r\n    return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n  }\r\n\r\n  static getPermission(): Promise<{}> {\r\n    this.initUserMedia();\r\n\r\n    // @ts-ignore\r\n    return navigator.mediaDevices.getUserMedia({ audio: true }).then((stream: MediaStream) => {\r\n      stream && stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n    });\r\n  }\r\n}\r\n"
        }
    ]
}