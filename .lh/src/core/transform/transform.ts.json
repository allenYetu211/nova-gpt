{
    "sourceFile": "src/core/transform/transform.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1681631792701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1681631792701,
            "name": "Commit-0",
            "content": "interface dataview {\r\n    byteLength: number,\r\n    buffer: {\r\n        byteLength: number,\r\n    },\r\n    getUint8: any,\r\n}\r\n\r\n/**\r\n * 在data中的offset位置开始写入str字符串\r\n * @param {TypedArrays} data    二进制数据\r\n * @param {Number}      offset  偏移量\r\n * @param {String}      str     字符串\r\n */\r\nfunction writeString(data: DataView, offset:number, str: string): void {\r\n    for (let i = 0; i < str.length; i++) {\r\n        data.setUint8(offset + i, str.charCodeAt(i));\r\n    }\r\n}\r\n\r\n/**\r\n * 数据合并压缩\r\n * 根据输入和输出的采样率压缩数据，\r\n * 比如输入的采样率是48k的，我们需要的是（输出）的是16k的，由于48k与16k是3倍关系，\r\n * 所以输入数据中每隔3取1位\r\n *\r\n * @param {float32array} data       [-1, 1]的pcm数据\r\n * @param {number} inputSampleRate  输入采样率\r\n * @param {number} outputSampleRate 输出采样率\r\n * @returns  {float32array}         压缩处理后的二进制数据\r\n */\r\nexport function compress(data: any, inputSampleRate: number, outputSampleRate: number) {\r\n    // 压缩，根据采样率进行压缩\r\n    let rate = inputSampleRate / outputSampleRate,\r\n        compression = Math.max(rate, 1),\r\n        lData = data.left,\r\n        rData = data.right,\r\n        length = Math.floor(( lData.length + rData.length ) / rate),\r\n        result = new Float32Array(length),\r\n        index = 0,\r\n        j = 0;\r\n\r\n    // 循环间隔 compression 位取一位数据\r\n    while (index < length) {\r\n        // 取整是因为存在比例compression不是整数的情况\r\n        let temp = Math.floor(j);\r\n\r\n        result[index] = lData[temp];\r\n        index++;\r\n\r\n        if (rData.length) {\r\n            /*\r\n            * 双声道处理\r\n            * e.inputBuffer.getChannelData(0)得到了左声道4096个样本数据，1是右声道的数据，\r\n            * 此处需要组和成LRLRLR这种格式，才能正常播放，所以要处理下\r\n            */\r\n            result[index] = rData[temp];\r\n            index++;\r\n        }\r\n\r\n        j += compression;\r\n    }\r\n    // 返回压缩后的一维数据\r\n    return result;\r\n}\r\n\r\n/**\r\n * 转换到我们需要的对应格式的编码\r\n *\r\n * @param {float32array} bytes      pcm二进制数据\r\n * @param {number}  sampleBits      采样位数\r\n * @param {boolean} littleEdian     是否是小端字节序\r\n * @returns {dataview}              pcm二进制数据\r\n */\r\nexport function encodePCM(bytes: any , sampleBits: number, littleEdian: boolean = true) {\r\n    let offset = 0,\r\n        dataLength = bytes.length * (sampleBits / 8),\r\n        buffer = new ArrayBuffer(dataLength),\r\n        data = new DataView(buffer);\r\n\r\n    // 写入采样数据\r\n    if (sampleBits === 8) {\r\n        for (let i = 0; i < bytes.length; i++, offset++) {\r\n            // 范围[-1, 1]\r\n            let s = Math.max(-1, Math.min(1, bytes[i]));\r\n            // 8位采样位划分成2^8=256份，它的范围是0-255;\r\n            // 对于8位的话，负数*128，正数*127，然后整体向上平移128(+128)，即可得到[0,255]范围的数据。\r\n            let val = s < 0 ? s * 128 : s * 127;\r\n            val = +val + 128;\r\n            data.setInt8(offset, val);\r\n        }\r\n    } else {\r\n        for (let i = 0; i < bytes.length; i++, offset += 2) {\r\n            let s = Math.max(-1, Math.min(1, bytes[i]));\r\n            // 16位的划分的是2^16=65536份，范围是-32768到32767\r\n            // 因为我们收集的数据范围在[-1,1]，那么你想转换成16位的话，只需要对负数*32768,对正数*32767,即可得到范围在[-32768,32767]的数据。\r\n            data.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, littleEdian);\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * 编码wav，一般wav格式是在pcm文件前增加44个字节的文件头，\r\n * 所以，此处只需要在pcm数据前增加下就行了。\r\n *\r\n * @param {DataView} bytes           pcm二进制数据\r\n * @param {number}  inputSampleRate  输入采样率\r\n * @param {number}  outputSampleRate 输出采样率\r\n * @param {number}  numChannels      声道数\r\n * @param {number}  oututSampleBits  输出采样位数\r\n * @param {boolean} littleEdian      是否是小端字节序\r\n * @returns {DataView}               wav二进制数据\r\n */\r\nexport function encodeWAV(bytes: dataview, inputSampleRate: number, outputSampleRate: number, numChannels: number, oututSampleBits: number, littleEdian: boolean = true) {\r\n    let sampleRate = outputSampleRate > inputSampleRate ? inputSampleRate : outputSampleRate,   // 输出采样率较大时，仍使用输入的值，\r\n        sampleBits = oututSampleBits,\r\n        buffer = new ArrayBuffer(44 + bytes.byteLength),\r\n        data = new DataView(buffer),\r\n        channelCount = numChannels, // 声道\r\n        offset = 0;\r\n\r\n    // 资源交换文件标识符\r\n    writeString(data, offset, 'RIFF'); offset += 4;\r\n    // 下个地址开始到文件尾总字节数,即文件大小-8\r\n    data.setUint32(offset, 36 + bytes.byteLength, littleEdian); offset += 4;\r\n    // WAV文件标志\r\n    writeString(data, offset, 'WAVE'); offset += 4;\r\n    // 波形格式标志\r\n    writeString(data, offset, 'fmt '); offset += 4;\r\n    // 过滤字节,一般为 0x10 = 16\r\n    data.setUint32(offset, 16, littleEdian); offset += 4;\r\n    // 格式类别 (PCM形式采样数据)\r\n    data.setUint16(offset, 1, littleEdian); offset += 2;\r\n    // 声道数\r\n    data.setUint16(offset, channelCount, littleEdian); offset += 2;\r\n    // 采样率,每秒样本数,表示每个通道的播放速度\r\n    data.setUint32(offset, sampleRate, littleEdian); offset += 4;\r\n    // 波形数据传输率 (每秒平均字节数) 声道数 × 采样频率 × 采样位数 / 8\r\n    data.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), littleEdian); offset += 4;\r\n    // 快数据调整数 采样一次占用字节数 声道数 × 采样位数 / 8\r\n    data.setUint16(offset, channelCount * (sampleBits / 8), littleEdian); offset += 2;\r\n    // 采样位数\r\n    data.setUint16(offset, sampleBits, littleEdian); offset += 2;\r\n    // 数据标识符\r\n    writeString(data, offset, 'data'); offset += 4;\r\n    // 采样数据总数,即数据总大小-44\r\n    data.setUint32(offset, bytes.byteLength, littleEdian); offset += 4;\r\n\r\n    // 给wav头增加pcm体\r\n    for (let i = 0; i < bytes.byteLength;) {\r\n        data.setUint8(offset, bytes.getUint8(i));\r\n        offset++;\r\n        i++;\r\n    }\r\n\r\n    return data;\r\n}\r\n"
        }
    ]
}